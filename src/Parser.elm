module Parser exposing (TranscriptLine, parseTranscriptionXML)

import Combine
    exposing
        ( (*>)
        , (<*)
        , ParseErr
        , ParseOk
        , Parser
        , andThen
        , between
        , many
        , manyTill
        , map
        , optional
        , or
        , parse
        , regex
        , skip
        , string
        , whitespace
        )
import Regex


type Transcript
    = UserGenerated
    | AutoGenerated


type alias TranscriptLine =
    { time : Int
    , content : String
    }


parseTranscriptionXML : String -> Result (ParseErr ()) (ParseOk () (List TranscriptLine))
parseTranscriptionXML transcription =
    parse transcriptionXML (noWhitespace transcription)


noWhitespace : String -> String
noWhitespace string =
    Regex.replace Regex.All (Regex.regex "\n") (\_ -> " ") string


transcriptionXML : Parser state (List TranscriptLine)
transcriptionXML =
    or userGeneratedClosedCaptions autoGeneratedClosedCaptions


userGeneratedClosedCaptions : Parser state (List TranscriptLine)
userGeneratedClosedCaptions =
    openingTag "?xml"
        *> openingTag "timedtext"
        *> openingTag "body"
        *> many (line UserGenerated)
        <* closingTag "body"
        <* closingTag "timedtext"


autoGeneratedClosedCaptions : Parser state (List TranscriptLine)
autoGeneratedClosedCaptions =
    openingTag "?xml"
        *> openingTag "timedtext"
        *> head
        *> openingTag "body"
        *> selfClosingTag "w"
        *> many (line AutoGenerated)
        <* closingTag "body"
        <* closingTag "timedtext"


head : Parser state (List String)
head =
    openingTag "head" *> manyTill anyCharacter (closingTag "head")


line : Transcript -> Parser state TranscriptLine
line transcriptType =
    let
        lineParser =
            case transcriptType of
                UserGenerated ->
                    manyTill anyCharacter (closingTag "p")

                AutoGenerated ->
                    manyTill word (or emptyLine (closingTag "p"))
    in
    openingTag "p"
        *> lineParser
        |> map (String.join "")
        |> map (Regex.replace Regex.All (Regex.regex "&#39;") (\_ -> "'"))
        |> map (Regex.replace Regex.All (Regex.regex "&quot;") (\_ -> "\""))
        |> map (\line -> { time = 1, content = line })


emptyLine : Parser state String
emptyLine =
    whitespace *> string "</p>" <* whitespace


word : Parser state String
word =
    openingTag "s"
        *> manyTill anyCharacter (closingTag "s")
        |> map (String.join "")


anyCharacter : Parser state String
anyCharacter =
    regex "."


openingTag : String -> Parser state (List String)
openingTag name =
    whitespace *> string ("<" ++ name) *> manyTill anyCharacter (string ">")


closingTag : String -> Parser state String
closingTag name =
    string ("</" ++ name ++ ">") <* whitespace


selfClosingTag : String -> Parser state (List String)
selfClosingTag name =
    whitespace *> string ("<" ++ name) *> manyTill anyCharacter (string "/>") <* whitespace
